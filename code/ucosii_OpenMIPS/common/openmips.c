#include "includes.h"

#define BOTH_EMPTY (UART_LS_TEMT | UART_LS_THRE)

#define WAIT_FOR_XMITR \
        do { \
                lsr = REG8(UART_BASE + UART_LS_REG); \
        } while ((lsr & BOTH_EMPTY) != BOTH_EMPTY)

#define WAIT_FOR_THRE \
        do { \
                lsr = REG8(UART_BASE + UART_LS_REG); \
        } while ((lsr & UART_LS_THRE) != UART_LS_THRE)

#define TASK_STK_SIZE 256

OS_STK TaskStartStk[TASK_STK_SIZE];

char Info[372]={0x48,0x69,0x21,0x20,0x4d,0x79,0x20,0x6e,0x61,0x6d,
				0x65,0x20,0x69,0x73,0x20,0x4b,0x49,0x4d,0x57,0x45,
				0x4e,0x47,0x2c,0x20,0x62,0x6f,0x72,0x6e,0x20,0x69,
				0x6e,0x20,0x31,0x39,0x39,0x36,0x2c,0x20,0x67,0x72,
				0x65,0x77,0x20,0x75,0x70,0x20,0x69,0x6e,0x20,0x54,
				0x61,0x69,0x70,0x65,0x69,0x2c,0x20,0x67,0x72,0x61,
				0x64,0x75,0x61,0x74,0x65,0x64,0x20,0x66,0x72,0x6f,
				0x6d,0x20,0x4e,0x61,0x74,0x69,0x6f,0x6e,0x61,0x6c,
				0x20,0x54,0x61,0x69,0x77,0x61,0x6e,0x20,0x4f,0x63,
				0x65,0x61,0x6e,0x20,0x55,0x6e,0x69,0x76,0x65,0x72,
				0x73,0x69,0x74,0x79,0x2e,0x0d,0x0a,0x4c,0x69,0x6b,
				0x65,0x20,0x74,0x6f,0x20,0x6c,0x65,0x61,0x72,0x6e,
				0x2c,0x20,0x6c,0x69,0x6b,0x65,0x20,0x74,0x6f,0x20,
				0x73,0x74,0x75,0x64,0x79,0x2e,0x0d,0x0a,0x49,0x20,
				0x61,0x6d,0x20,0x70,0x61,0x73,0x73,0x69,0x6f,0x6e,
				0x61,0x74,0x65,0x20,0x61,0x62,0x6f,0x75,0x74,0x20,
				0x68,0x61,0x72,0x64,0x77,0x61,0x72,0x65,0x20,0x63,
				0x69,0x72,0x63,0x75,0x69,0x74,0x20,0x64,0x65,0x73,
				0x69,0x67,0x6e,0x20,0x73,0x75,0x63,0x68,0x20,0x61,
				0x73,0x20,0x64,0x69,0x67,0x69,0x74,0x61,0x6c,0x20,
				0x61,0x6e,0x64,0x20,0x61,0x6e,0x61,0x6c,0x6f,0x67,
				0x2c,0x20,0x61,0x6e,0x64,0x20,0x73,0x6f,0x66,0x74,
				0x77,0x61,0x72,0x65,0x20,0x64,0x65,0x73,0x69,0x67,
				0x6e,0x20,0x73,0x75,0x63,0x68,0x20,0x61,0x73,0x20,
				0x6f,0x70,0x65,0x72,0x61,0x74,0x69,0x6e,0x67,0x20,
				0x73,0x79,0x73,0x74,0x65,0x6d,0x20,0x64,0x65,0x76,
				0x65,0x6c,0x6f,0x70,0x6d,0x65,0x6e,0x74,0x2e,0x0d,
				0x0a,0x49,0x20,0x61,0x6d,0x20,0x68,0x61,0x70,0x70,
				0x79,0x20,0x74,0x6f,0x20,0x73,0x68,0x61,0x72,0x65,
				0x20,0x6c,0x65,0x61,0x72,0x6e,0x69,0x6e,0x67,0x20,
				0x6f,0x75,0x74,0x63,0x6f,0x6d,0x65,0x73,0x20,0x61,
				0x6e,0x64,0x20,0x70,0x61,0x73,0x73,0x20,0x6f,0x6e,
				0x20,0x74,0x68,0x65,0x20,0x6b,0x6e,0x6f,0x77,0x6c,
				0x65,0x64,0x67,0x65,0x20,0x74,0x6f,0x20,0x6f,0x74,
				0x68,0x65,0x72,0x73,0x20,0x62,0x79,0x20,0x65,0x64,
				0x69,0x74,0x69,0x6e,0x67,0x20,0x74,0x75,0x74,0x6f,
				0x72,0x69,0x61,0x6c,0x20,0x76,0x69,0x64,0x65,0x6f,
				0x73,0x2e};
				 
void uart_init(void)
{
        INT32U divisor;
 
         /* Set baud rate */
	
        divisor = (INT32U) IN_CLK/(16 * UART_BAUD_RATE);

        REG8(UART_BASE + UART_LC_REG) = 0x80;
        REG8(UART_BASE + UART_DLB1_REG) = divisor & 0x000000ff;
        REG8(UART_BASE + UART_DLB2_REG) = (divisor >> 8) & 0x000000ff;
        REG8(UART_BASE + UART_LC_REG) = 0x00;
        
        
        /* Disable all interrupts */
       
        REG8(UART_BASE + UART_IE_REG) = 0x00;
       
 
        /* Set 8 bit char, 1 stop bit, no parity */
        
       REG8(UART_BASE + UART_LC_REG) = UART_LC_WLEN8 | (UART_LC_ONE_STOP | UART_LC_NO_PARITY);
        
  
        uart_print_str("UART initialize done ! \n");
	return;
}

void uart_putc(char c)
{
        unsigned char lsr;
        WAIT_FOR_THRE;
        REG8(UART_BASE + UART_TH_REG) = c;
        if(c == '\n') {
          WAIT_FOR_THRE;
          //REG8(UART_BASE + UART_TH_REG) = '\r';
        }	
        WAIT_FOR_XMITR;  
  
}

void uart_print_str(char* str)
{
       INT32U i=0;
       OS_CPU_SR cpu_sr;
       OS_ENTER_CRITICAL()
       
       while(str[i]!=0)
       {
       	uart_putc(str[i]);
        i++;
       }
        
       OS_EXIT_CRITICAL()
        
}

void gpio_init()
{
	REG32(GPIO_BASE + GPIO_OE_REG) = 0xffffffff;
	REG32(GPIO_BASE + GPIO_INTE_REG) = 0x00000000;
	gpio_out(0x0f0f0f0f);
	uart_print_str("GPIO initialize done ! \n\n\n");
        return;
}

void gpio_out(INT32U number)
{
	

	  REG32(GPIO_BASE + GPIO_OUT_REG) = number;
	  

}

INT32U gpio_in()
{
	INT32U temp = 0;
	

	
	 temp = REG32(GPIO_BASE + GPIO_IN_REG);
	  

	
	return temp;
}

/*******************************************
   
    ÉèÖÃcompareŒÄŽæÆ÷£¬²¢ÇÒÊ¹ÄÜÊ±ÖÓÖÐ¶Ï    

********************************************/
void OSInitTick(void)
{
    INT32U compare = (INT32U)(IN_CLK / OS_TICKS_PER_SEC);
    
    asm volatile("mtc0   %0,$9"   : :"r"(0x0)); 
    asm volatile("mtc0   %0,$11"   : :"r"(compare));  
    asm volatile("mtc0   %0,$12"   : :"r"(0x10000401));
    //uart_print_str("OSInitTick Done!!!\n");
    
    return; 
}

void  TaskStart (void *pdata)
{
    INT32U count=0;
    INT32U count_tmp;
    INT32U num;
    INT32U num_out;
	INT32U num_result;
	INT32U i;
    pdata = pdata;            /* Prevent compiler warning                 */
    OSInitTick();	      /* don't put this function in main()        */    
	   
    //for (;;) {
    //   if(count <= 372)
    //	{
    //     uart_putc(Info[count]);
    //     uart_putc(Info[count+1]);
    //    }
    //    gpio_out(count);
    //    count=count+2;
    //    OSTimeDly(10);  /* Wait 100ms                   */
    //}
	
	while (1) {
		if(count <= 372)
		{
			uart_putc(Info[count]);
			count+=1;
        }
		
		count_tmp = count;
		num_result=0;//開始用for迴圈一一析出個、十、百、千位數，num_result進入回圈內都要先歸0
		for(i=0; i<4; i++) 
		{	
			num = count_tmp%10;
			count_tmp/=10;
			
			switch(num)
			{
				case 0:
					num_out=0b11000000;//<==讓七段顯示器顯示"0"，0b表示2進制
					break;
				case 1:
					num_out=0b11111001;
					break;
				case 2:
					num_out=0b10100100;
					break;
				case 3:
					num_out=0b10110000;
					break;
				case 4:
					num_out=0b10011001;
					break;
				case 5:
					num_out=0b10010010;
					break;
				case 6:
					num_out=0b10000010;
					break;
				case 7:
					num_out=0b11111000;
					break;
				case 8:
					num_out=0b10000000;
					break;
				default://case 9
					num_out=0b10010000;
			}
			
			switch(i) 
			{
				case 0:
					num_result += num_out;
					break;
				case 1:
					num_result += num_out*256;//num_out*(2^8)
					break;
				case 2:
					num_result += num_out*65536;//num_out*(2^16)
					break;
				default://case 3
					num_result += num_out*16777216;//num_out*(2^24)
			}
		}
        gpio_out(num_result);
        OSTimeDly(10);  /* Wait 100ms                   */
    }
    
}

void main()
{
  OSInit();
  
  uart_init();
  
  gpio_init();	
  
  OSTaskCreate(TaskStart, 
	       (void *)0, 
	       &TaskStartStk[TASK_STK_SIZE - 1], 
	       0);
  
  OSStart();  
  
}
